---
sidebar_position: 2
sidebar_label: 'script-includes'
---

## script-includes

**执行于：服务器**

​		script-includes 是一个存储库可重用的代码。它在服务器上可用并执行，不需要包含在页面中或加载到表单中。任何在**服务器端**执行并与脚本包含在同一范围内的代码，都可以像系统中的任何其他 API 一样调用它。

脚本包含不会像业务规则那样由数据库操作触发，也不会像客户端脚本那样由事件触发。相反，脚本包含是存在于服务器上并从其他服务器端脚本调用的脚本。您不能直接从客户端脚本调用脚本包含，但您可以通过扩展 GlideAjax 类使脚本包含从客户端脚本（尽管它仍然在服务器上执行）可访问。更多关于 GlideAjax 以及如何在以后的章节中使用它。现在，只要说脚本只包含执行就足够了在服务器上，通常仅在从另一个服务器端脚本调用时。

script-includes是 UI 脚本的服务器端等价物（我们将在下一章中详细了解），因为它们实际上是存在于给定应用程序范围内的服务器上的有效代码块。

每个脚本包含在 JET 中定义一个类或函数，可从其范围内的任何服务器端脚本访问。脚本包含记录本身的名称必须与`Script`记录字段中的函数或类的名称匹配，因为这也是 API 名称。

脚本包含可以在应用程序导航器中的**系统定义**|下找到。**script-includes**.

脚本包含的默认结构如下所示：

```
var ExampleScriptInclude = Class.create();
ExampleScriptInclude.prototype = {
    初始化：函数（）{
        //构造函数
    },
    一个方法：函数（）{
        //做一些事情
    },
    另一个方法：函数（）{
        //做一些其他的事情
    },
    类型：'ExampleScriptInclude'
};
```

当您键入值到`Name`新的**脚本包含**记录的字段中，**脚本**字段将自动填充一个基本脚手架，定义一个具有您指定名称的脚本包含类和一个初始化函数。初始化函数是一个构造方法，当使用`new`关键字初始化新对象时会自动调用该方法，如下例所示：

```
var esi = new ExampleScriptInclude();
```

如果我们在`initialize()`方法中接受参数，我们就可以在构造对象时指定参数。例如，我们可以将初始化函数描述更改为如下所示：

```
初始化：函数（constructorArg）{
    this.constructorArg = 构造函数参数；
}
```

现在，当从这个类实例化一个对象时，我们可以指定一个构造函数参数，如下所示：

```
var esi = new ExampleScriptInclude('arg value');
```

使用前面的代码，局部变量`constructorArg`将被设置为`'arg value'`，并且可用于类中的任何其他函数`this.constructorArg`。

尽可能不要修改开箱即用的 JET 脚本包含。相反，创建一个副本并在其中包含您的更改。要添加功能而不是修改它，您还可以通过更改类似于以下代码突出显示部分的声明来扩展现有脚本包含，这扩展了 OOB（开箱即用）`Cart`script-includes：

```
var test = Class.create();
test.prototype = Object.extendsObject(Cart, {
自定义方法：函数（）{
//你的代码在这里
},
    类型：'测试'
});
```

如果有帮助的话，最好避免对 OOB script-includes以及任何 OOB 记录进行更改。有时候帮不上忙，没关系，但是做的时候最好小心点所以是双重的：

- 修改 OOB 记录意味着未来的升级将无法更新它们。例如，如果您将实例从赫尔辛基升级到伊斯坦布尔，它可能会更改购物车 API 的某些功能。但是，如果购物车脚本包含已被您的实例中的某个人修改而不是被扩展，则升级过程将无法修改该脚本包含，并且您将需要手动解决升级错误。

  ### 提示

  升级错误，也称为冲突，在升级过程中很常见，并不是什么大问题，但您希望尽可能避免它们。它们随着时间的推移而增加，并且可以为升级过程增加大量时间和精力。

- 如果修改现有记录以更改所引用的功能，则引用或使用 OOB 脚本的任何其他脚本都可能会中断。