---
sidebar_position: 3
sidebar_label: 'business-rules'
---

# 业务规则

**业务规则**在选中**高级设置**复选框时支持自定义脚本，在**脚本**字段中显示。

![业务规则显示](/img/server-side-scripting/业务规则显示.png)



​		`Display业务规则`是特殊的一类，当一条记录与`执行条件`部分所描述的运行条件匹配时，就会在服务器上执行，最终在表单展示。这些业务规则可以访问一个名为`g_scratchpad` 的对象. 该对象可以存储来自服务器端脚本的数据，并且可以通过任何客户端脚本访问它。通过这种方式，您可以在给定的一组条件下轻松地将数据从服务器呈现给客户端。

​		业务规则在**服务端**执行，因此通常服务器端 API 可用于执行任何可能需要执行的脚本。和许多其他服务器端脚本一样，`current`和`previous`对象也是可用的,该对象是包含当前记录的预填充 GlideRecord;  即通过插入、查询或修改触发业务规则运行的记录。`current`和`previous`对象也可用于业务规则，但需要注意`previous`在业务规则异步运行时不可用。

​		业务规则对于何时可以运行具有更高的粒度级别。管理员可以选择在将记录或更新保存到数据库之前或之后运行业务规则。

![image-20220511151013207](/img/server-side-scripting/业务规则时机.png)

​		业务规则有多种类型，它们在不同的时间执行。在本节中，我们将了解它们中的每一个以及它们的用途。

## before业务规则

​		例如假设我正在查看事件单，并将**State**字段更改为**Closed**，保存记录后，该记录更新被发送到数据库；但是如果我们有一个业务规则，其中**执行时序**字段设置为**before**，那么每次在将记录保存到数据库之前，业务规则中的任何脚本都将执行。另外需要注意的是，也为您提供了`current`对象的`setAbortAction()`方法，在`current`对象更新到数据库时可以拒绝执行任何业务规则：

```
current.setAbortAction(true);
```

​		中止`before`业务规则中的更新还可以防止其他业务规则针对记录运行，因为一旦中止，就不会执行任何数据库操作（不插入/更新记录）。**执行时序**字段确定业务规则在哪个阶段运行，但在该阶段，**排序**字段确定它们运行的顺序。在可能中止数据库操作时记住这一事实很重要。例如，如果另一个业务规则首先运行并更新另一个记录，则在稍后运行的业务规则中，中止数据库操作不会撤消先前具有较低**排序**字段值的业务规则所做的更改。

​		但是，还有另一种方法可以防止在更新记录时运行其他业务规则。GlideRecord API 有一个名为的方法`setWorkflow()`，它接受一个布尔 ( `true`/ `false`) 值作为参数。执行后续数据库操作时，不会运行任何业务规则。这是一个使用示例：

```javascript
var gr = new GlideRecord('incident'); 
gr.get('176baa97c0a80169011360192b738ebf'); 
gr.setValue('active', 'true'); 
gr.setWorkflow(false); 
gr.update(); 
```

我们所选记录的更新时,上面的代码将防止任何业务规则自动运行。

在业务规则中您还可以调用`current` 对象的 GlideRecord方法，使用`current.setAbortAction(true)`. 这将阻止任何业务规则的运行，无论它是在业务规则之前还是之后使用。

## After业务规则

​	![image-20220511161610887](/img/server-side-scripting/after业务规则.png)

​	除了`before`业务规则，我们还提到了`after`业务规则，如您所料，在数据库操作完成后执行。由于在将记录保存到数据库之前执行业务规则之前，`current`在业务规则的脚本或操作的上下文中对对象所做的任何更改都会自动保存到数据库中。以下是一个例子：

```javascript
if (current.getValue('state') == '5') {
    current.setValue('active', 'false');
}
```

注意我们不做任何事情将记录提交到数据库以进行插入/更新。使用`before`业务规则时，无需调用`current` 对象的`update()`方法，因为无论如何它都将被保存到数据库中！但是，使用`after`业务规则，您需要调用`update()`以提交当前对象中的新数据，如下所示：

```javascript
if (current.getValue('state') == '5') { 
    current.setValue('active', 'false'); 
    current.update(); 
} 
```



## Asynchronous(异步)业务规则

​		`异步业务规则`在`after业务规则`之后执行。服务器在`after业务规则`之后向客户端返回响应，这意味着当表单重新加载时，将显示任何`after业务规则`的结果，但不会显示`异步业务规则`的结果。当服务器有可用资源时，服务器上通常会在稍后的几秒钟内运行`异步业务规则`。

​		`异步业务规则`通常是更新非当前记录，并且在表单重新加载时不需要显示这些记录的最佳方式。可以使用`after业务规则`来完成该任务，但这不是完成该任务的最高效的方式。另外需要注意不能使用 `异步业务规则`的例外场景：当您需要访问`previous`对象时，该对象仅在`before业务规则`和`after业务规则`可用。



## Display业务规则和 g_scratchpad

​		当请求在表单中显示一条记录时，`Display业务规则`在服务器上执行；但在数据从服务器发送到客户端之前，`current`对象可用于`Display业务规则`，但对字段值的任何更改在发送到客户端并显示在表单中时都不是永久性的，除非用户使用新值保存记录。`Display业务规则`中所做的任何更改应该视为修改后传输到客户端的数据，而不是数据库中的数据。

​		`Display业务规则`最常见的用法是在`g_scratchpad`对象上设置值。此对象与有关记录的其余数据一起传递给客户端，这意味着它也可以在客户端上访问。因此，`Display业务规则`可用于从服务器检索数据并将其发送到客户端。这是一种非常高效且有效的对异步查询或 GlideAjax调用的替代方案，因为数据在客户端加载时便可获得，而不必等待异步 Ajax响应。

​		设置变量在`异步业务规则中`使用`g_scratchpad`示例如下：`g_scratchpad.propName = propVal;`同样，在客户端脚本中检索该值非常简单：`var propVal = g_scratchpad.propName;`如您所见，`g_scratchpad`变量是只是一个对象，其属性的值可以像任何其他对象一样设置和检索。

​		以下是何时使用`Display业务规则`很好的例子，是当您需要将表单中的字段与服务器上相同字段的值进行比较时，这是一个实现示例：

```javascript
(function executeRule(current, previous /*null when async*/) {
    g_scratchpad.originalStateVal = current.getValue('state');
})(当前，上一个);
```

## 总结	

​		根据最佳实践的经验，`before业务规则`用来更新`current`对象，`after业务规则`用来更新关联记录（例如数据记录加载时需要显示的引用字段、列表记录）等，`异步业务规则`用来更新表单重新加载后不需要显示或加载的操作或记录，`Display业务规则`用于在客户端脚本加载时，向客户端检索并提供server端的数据。

