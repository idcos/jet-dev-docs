---
sidebar_position: 3
sidebar_label: 'business-rules'
---

# 业务规则

业务规则在服务器上执行，因此通常的服务器端 API 可用于任何可能需要运行的脚本。`current`和`previous`对象也可用于业务规则，但`previous`在业务规则异步运行时不可用。

业务规则对于何时可以运行具有更高的粒度级别。管理员可以选择在将记录或更新保存到数据库之前或之后运行业务规则。

例如，假设我正在查看事故单，并将**State**字段更改为**Closed**。保存记录后，该记录更新被发送到数据库；但是，如果我们有一个业务规则，其中**When**字段设置为**before**，那么在将记录保存到数据库之前，其中的任何脚本都将在该记录上执行。`setAbortAction()`需要注意这一点，因为它为您提供了另一种在更新到达数据库之前使用对象的方法拒绝更新的方法`current`：

```
current.setAbortAction(true);
```

中止之前业务规则中的更新还可以防止其他业务规则针对记录运行，因为一旦中止，就不会执行任何数据库操作（不插入/更新记录）。**When**字段确定业务规则在哪个阶段运行，但在该阶段，**Order**字段确定它们运行的顺序。在可能中止数据库操作时记住这一事实很重要。例如，如果另一个业务规则首先运行并更新另一个记录，则在稍后运行的业务规则中中止数据库操作不会撤消先前具有较低**Order**字段值的业务规则所做的更改。

但是，还有另一种方法可以防止在更新记录时运行其他业务规则。GlideRecord API 有一个名为 的方法`setWorkflow()`，它接受一个布尔 ( `true`/ `false`) 值作为参数。执行后续数据库操作时，不会运行任何业务规则。这是一个使用示例：

```
var gr = new GlideRecord('事件');
gr.get('176baa97c0a80169011360192b738ebf');
gr.setValue('active', 'true');
gr.setWorkflow（假）；
gr.update();
```

上面的代码将防止任何自动业务逻辑由于我们对所选记录的更新而运行。

您还可以`current`在业务规则中对 GlideRecord 对象调用此方法，使用`current.setAbortAction(true)`. 这将阻止任何进一步的业务规则运行，无论它是在业务规则之前还是之后使用。

业务规则有多种类型，它们在不同的时间执行。在本节中，我们将了解它们中的每一个以及它们的用途。



## 后业务规则

除了之前的业务规则，我们还提到了业务规则之后，如您所料，在数据库操作完成后执行。由于在将记录保存到数据库之前执行业务规则之前，`current`在业务规则的脚本或操作的上下文中对对象所做的任何更改都会自动保存到数据库中。这是一个例子：

```javascript
if (current.getValue('state') == '5') {
    current.setValue('active', 'false');
}
```

注意我们做了不做任何事情将记录提交到数据库以进行插入/更新。使用*前置*业务规则时，无需调用对象`update()`上的方法`current`，因为无论如何它都将被保存到数据库中！但是，使用*after*业务规则，您需要调用`update()`以提交当前对象中的新数据，如下所示：

```javascript
if (current.getValue('state') == '5') {
    current.setValue('active', 'false');
    当前.更新（）；
}
```



## 异步业务规则

异步业务规则在业务规则*之后*执行。然而*服务器在after*业务规则之后向客户端返回响应，这意味着当表单重新加载时，将显示任何*after*业务规则的结果，但不会显示*异步*业务规则的结果。稍后将在服务器上运行异步规则；通常只在几秒钟后，当服务器有可用资源运行它时。

异步业务规则通常是更新非当前记录的最佳方式，并且在表单重新加载时不需要显示这些记录。可以使用*after* business 规则来完成该任务，但这不是完成该任务的最高效的方式。但是，主要的例外是当您需要访问`previous`对象时，该对象仅在业务规则*之前*和*之后可用。*

### 显示业务规则和 g_scratchpad

显示业务规则发出请求时在服务器上执行在表单中显示一条记录，但在数据从服务器发送到客户端之前。该`current`对象可用于*显示*业务规则，但对字段值的任何更改在发送到客户端并显示在表单中时都不是永久性的，除非用户使用新值保存记录。*将显示*业务规则中所做的任何更改视为修改传输到客户端的数据，而不是数据库中的数据。

*显示*业务规则最常见的用法是在`g_scratchpad`对象上设置值。此对象与有关记录的其余数据一起传递给客户端，这意味着它也可以在客户端上访问。因此，*显示*业务规则可用于从服务器检索数据并将其发送到客户端。这可能是一种非常高效和有效的替代方案，可以根据情况使用异步查询或 GlideAjax 调用，因为数据在客户端加载时可用，而不必等待异步 AJAX 响应。

设置变量在异步业务规则中使用`g_scratchpad`就像：`g_scratchpad.propName = propVal;`. 同样，在客户端脚本中检索该值非常简单：`var propVal = g_scratchpad.propName;`. 如您所见，`g_scratchpad`变量是只是一个对象，其属性的值可以像任何其他对象一样设置和检索。

一个很好的例子何时使用*显示*业务规则，是当您需要将表单中的字段与服务器上相同字段的值进行比较时。这是一个如何实现的示例：

```javascript
(function executeRule(current, previous /*null when async*/) {
    g_scratchpad.originalStateVal = current.getValue('state');
})(当前，上一个);
```

最佳实践规定，*在*使用业务规则更新`current`对象之前，*在*使用业务规则更新相关记录（例如在记录加载时可能需要显示的引用字段和相关列表中的记录）之后，应使用*异步*业务规则更新记录并执行表单重新加载后不需要显示或加载的操作，*显示*业务规则应用于在加载时检索服务器端信息并将其提供给客户端脚本。