---
sidebar_position: 1
sidebar_label: 'structure-api-class'
---
# API类的结构

首先，让我们定义几个术语。根据 Mozilla 的面向对象 JavaScript 文档，JavaScript 确实是一种**无类语言**。然而，`class`语法是在语言之上添加的，所以在 JavaScript 中，一个**类**有点像对象的模板。一个类在技术上也是一个对象。类定义预先定义了从类生成的对象的方法和属性。大多数有经验的 JavaScript 开发人员都会熟悉一个类似的概念：**原型对象**。

一个**对象**因此，在这种情况下，它只是一个**类**的实例！这些类与您可能熟悉的原型构造函数仅略有不同，并且这些类的**实例**以原型对象相同的方式生成：使用`new`关键字。

```
var grIncident = new GlideRecord('事件');
```

**方法**是一种声明为类的一部分的函数或子例程（以及作为该类实例的任何对象）。

**构造函数**是`new`一种特殊类型的函数，当使用关键字将对象声明为类的新实例时运行。在 **JET** 的服务端脚本中，这个构造函数通常称为初始化。在实例化期间传递给类的任何参数（使用`new`关键字）都将传递给此函数，由该函数构建将要返回的对象。

### 笔记

命名约定规定，变量名（包括函数名）使用驼峰式大写，类名和独立构造函数名使用首字母大写。

这是一个非常简单的示例类：

```
var MyClass = Class.create(); 
MyClass.prototype = { 
    initialize: function(initArg) { 
        this.localProperty = initArg; 
    }, 
    getLocalProperty: function() { 
        return this.localProperty; 
    }, 
    type: 'MyClass' 
};
```

现在让我们分解一下逐行，看看它是如何工作的。

在*第 1 行*，我们声明我们的类`MyClass`使用特殊的**JET API** ： `Class.create()`。`**JavaScript**` 在技术上没有称为**Class**的数据类型。至少在 ES5 中不是，它是在服务器上执行的 JavaScript 版本。相反，此代码依赖于函数/原型对象扩展。为了简化这一点，并提供更类似于后端 Java 的语法（并且更类似于大多数面向对象的编程语言使用的），**JET平台**提供了这一种生成基本类式对象的简单方法。

在*第 2 行*及以后，我们采用我们在第 1 行生成的这个基本类脚手架，并通过向其添加一些东西来扩展该原型（大括号：`{}`之间的所有内容）。

在*第 3 行*，我们声明了`initialize`方法。这是我们类的一个特殊方法（类似于有参构造器），每当使用`new`关键字从我们的类生成（实例化）新对象时都会自动调用该方法，如下所示：

```
var myObj = new MyClass('input');
```

`input`传递给这个实例化过程的任何参数（前面例子中的字符串），都会传递给这个初始化方法。

接下来，在第 4 行，我们使用关键字在实例化对象的范围内设置一个属性this。在这种情况下，每当我们创建此类的实例时，调用的属性都将使用传递给构造函数 `function (initArg)`的值`initArg`对`this.localProperty`进行初始化。

在*第 6 行*，我们声明了另一个`getLocalProperty`函数，这是一个可以从我们的类创建的对象中调用的方法，并且（在*第 7 行*）返回在初始化时设置的属性的值。

最后，在*第 9 行*，我们声明了类（和实例化对象）的类型属性。这只是一个字符串，你可以通过它确定子对象从哪个类创建。

