---
sidebar_position: 5
sidebar_label: 'ui-scripts（暂未实现）'
---
`UI-scripts` 类似于 `script includes`，但是script includes是运行在服务器端的代码库，`UI-scripts` 是运行在客户端的代码库。

全局`UI-scripts`相对简单，它们可以在系统中的任何形式上使用，因为它们与所有其他相关信息（记录数据、客户端脚本和其他数据）一起从服务器发送到浏览器。当`UI-scripts`设置为全局时，任何其他客户端脚本都可以访问其中的代码。例如，想象一下，我们有一个`UI-scripts`，其中包含以下代码：
```
function sayHello() { 
    alert('Hello!'); 
} 
```
如果我们将此`UI-scripts`标记为全局，那么在任何客户端脚本或界面策略脚本上，我们都可以调用sayHello()。调用后用户将看到一条警告消息，上面写着“Hello!”，即使执行该操作的函数在调用它的脚本的任何地方都没有定义。

此外，如果我们不将代码包装在函数中（或者，如果在界面策略中，我们调用函数，正如您在以下代码片段中看到的那样），那么该代码将在`UI-scripts`加载的每个页面上执行。
```
function sayHello() { 
    alert('Hello!'); 
} 
sayHello(); 
```

然而，非全局`UI-scripts`有点不同，因为它们不会加载到系统中的每个表单上。相反，您必须告诉系统何时将它们与页面的其余部分一起加载。这通常通过创建新的UI宏和格式化程序来实现。

可以从System UI | UI宏创建新的UI宏。给宏一个名称，然后在`<j:jelly>`和`</j:jelly>`标签之间输入以下行：
```
<g:requires name="ui_script_name.jsdbx" /> 
```

这是用Jelly编写的，Jelly是可执行XML的一种形式。这里唯一需要注意的是，我们告诉系统，我们即将创建的将使用此UI宏的UI格式化程序将使用我们定义的UI脚本。在这种情况下，ui_script_name。将此替换为UI脚本的名称，后跟.jsdbx扩展名，UI宏将导致UI脚本加载到它所打开的页面上。保存记录。

定义UI宏后，您需要创建一个格式化程序来将UI宏放置在表单中。您可以在应用程序导航器中从System UI|Formatters创建新的格式化程序。

给它一个名称，告诉它要在哪个表上运行（我们将使用事件[事件]作为示例），并在格式化程序字段中输入您定义的UI宏的名称。确保类型字段设置为格式化程序。也保存该记录。

最后，转到您选择的表格（通过打开记录）。打开表单设计器（配置|表单设计）。在左侧列表底部找到新创建的格式化程序。

将新格式化程序拖到表单上的任意位置，保存新布局，下次加载该表单时，您的UI宏将执行，您将看到警报！

如上所述，您可以通过将UI脚本全局化来做同样的事情，而无需UI宏的所有麻烦，但随后您无法控制它何时加载，这可能会影响性能。
