---
sidebar_position: 4
sidebar_label: '工作流'
---
&emsp;&emsp;工作流程JET 是具有拖放界面的流程图驱动的自动化工具。工作流可用于使用各种工具自动化多步骤流程，包括批准、子任务生成、通知、逻辑循环和脚本、if/then 控制流、计时器，它们甚至可以等待用户活动并对用户活动做出反应。

&emsp;&emsp;每个工作流的版本都存储在Workflow Versions [ wf_workflow_version] 表中。当任务与为工作流设置的标准匹配时，该工作流将针对该任务执行，并对其执行活动。一个工作流版本和一个任务之间的这种关系称为上下文。上下文存储在Workflow Context [ wf_context] 表中。

&emsp;&emsp;此设置是必要的，因为您可能有一天将工作流版本 1作为发布的工作流版本，并且当天创建的任何任务都将使用该工作流执行。但是，如果您对工作流程进行更改并重新发布它（从而创建同一工作流程的新版本），您不会希望从头开始每个现有任务；因此现有任务将继续使用给定版本的工作流执行（无论是在创建任务时发布的哪个版本），新任务将使用现在新发布的工作流执行。

&emsp;&emsp;图形工作流编辑器（工作流|应用程序导航器中的工作流编辑器）以流程图的形式为您提供给定工作流的内容和流程的可视化表示。工作流中的框被称为（并对应于）工作流执行的活动。在各种活动之间绘制的线对应于任务的流程，称为流转：

![workflows](/img/tasks-workflows/workflows.png)

&emsp;&emsp;当一个活动中工作流完成后，流转将执行流程图中的下一个工作流活动。在大多数情况下，这种流转是序列化的或线性的；从一项活动到另一项活动。也许循环回来，但总是一次执行一个活动：

![workflows2](/img/tasks-workflows/workflows_2.png)

&emsp;&emsp;但是，一个活动也可以从一个退出条件中绘制多条线，指向多个活动。如果是这种情况，这些活动将同时执行：

![workflows3](/img/tasks-workflows/workflows_3.png)

&emsp;&emsp;在这种情况下，可以保存其中一个分支没有退出条件（流转到另一个活动）的工作流程，但不建议这样做。相反，JET 提供了一个Join活动，您可以使用它来将不同的路径合并回单个流转流：

![workflows4](/img/tasks-workflows/workflows_4.png)

### 提示

&emsp;&emsp;与Join活动没有太大不同，JET 中的 Workflows 也有一个分支活动。但是，使用此活动与在活动上从单个退出条件绘制多条过渡线完全相同！

&emsp;&emsp;您可能已经注意到，每个活动在活动框底部都有一个黄色退出条件。到目前为止，我们讨论的活动只有一个退出条件，称为Always。单击此退出条件右侧的小方块，并将一条线拖到另一个活动，允许我们创建从第一个活动到下一个活动的流转。但是，某些活动可以有多个退出条件。Join 活动就是这样一个例子，因为它有两个退出条件：Complete和Incomplete。

&emsp;&emsp;如果您将两个或多个活动的流转绘制到 Join 活动中，则 Join 活动将等待流转到它的所有活动完成，然后再流转到下一个活动。但是，在某些情况下，替代执行路径可能会在某些永远不会重定向回Join活动的活动上终止。如果发生这种情况，那么将触发Join活动的Incomplete退出条件；否则，将触发Complete退出条件。因此，最好从Join中的Incomplete退出条件绘制一个流转活动，只要前面的活动有可能遵循不一定返回到该Join活动的流转路径；否则，您的工作流程可能会卡住！

## Important workflow activities（重要的工作流程活动）

&emsp;&emsp;现在我们有了一个基本的了解工作流的工作原理后，让我们回顾一下一些常用的工作流活动、它们的使用方式以及它们的用途。我们不会介绍所有可能的工作流活动，但为了让您更好地了解工作流是如何工作的，我们将介绍所有最流行和最有用的活动。

### 用户和组批准

&emsp;&emsp;批准 - 组和批准 - 用户是这两种工作流活动都会生成批准请求，但方式不同：

![approval](/img/tasks-workflows/approval.png)

&emsp;&emsp;批准 -用户活动将为单个用户创建一个或多个批准请求。您可以在此活动中将用户和组都添加为批准者，但在添加组时，此活动实际上会为该组中的每个用户生成单独的批准请求：

![approval2](/img/tasks-workflows/approval_2.png)

&emsp;&emsp;如果您要选中“高级”框，您甚至可以使用脚本来生成其他用户以供批准，方法是将预定义变量 ( answer) 设置为与您要请求批准的用户列表相对应的 Sys ID 数组来自（除了在用户和组字段中指定的那些。

&emsp;&emsp;通常，最好指定一个组，或使用脚本以编程方式确定批准者应该是谁，而不是硬编码用户列表。想象一下，如果我们硬编码为某种类型请求的批准者的用户突然离开公司。大多数公司都有一个开发和批准周期，需要几天甚至几周的时间才能将变更部署到生产环境，包括工作流程变更。但是，ServiceNow 中的某些内容被视为数据，而不是配置；数据通常可以在生产中直接更新，而配置（包括工作流）通常不能。

&emsp;&emsp;虽然工作流通常不能无需更改请求和批准即可更新，组成员身份和组所有权通常可以；所以如果我们可以使用脚本来抓取某个组的所有者，那么我们所要做的就是确保如果一个人离开公司，他们管理的任何组都有其他人代替管理字段，这样审批继续发挥作用。

&emsp;&emsp;用户批准，如组批准，还允许您设置批准请求被视为批准（或拒绝）的条件。您可以将其设置为等待：任何人批准、每个人都批准、任何个人的第一个响应或基于脚本的条件。在脚本中，您可以确定批准人的总数，然后等待超过 50% 的人批准或拒绝。或者，您可以将其设置为如果有人拒绝，则整个批准请求都将被拒绝。
最后，您甚至可以设置截止日期，以便用户必须在指定的时间范围内回复。

&emsp;&emsp;Approval - Group活动与Approval - User高度相似，只是您只能指定要批准的组（而不是单个用户），而等待条件更面向组：每个组的批准，任何组的批准, 所有组中每个人的批准，等等：

![approval3](/img/tasks-workflows/approval_3.png)

### 审批协调器

&emsp;&emsp;审批协调器工作流活动功能有点类似于编程中的复杂布尔表达式，因为它允许您生成批准，其结果取决于其所有先前活动的结果。因此，您可能有一个 Approval Coordinator 活动，它由一个Approval - Group活动、两个Approval - User活动，甚至一个Manual Approval活动提供。然后，您可以使用审批协调器来确定工作流对应的记录的总体审批状态。

### if

&emsp;&emsp;If工作流活动根据条件控制工作流中其他活动的流程：

![if](/img/tasks-workflows/if.png)

&emsp;&emsp;可以根据条件构建器定义条件（如前面的屏幕截图所示），或者如果我们选中Advanced复选框，我们可以编写一个脚本来确定If活动是否应该返回 true 或 false。单击高级复选框后，将显示脚本字段。该字段会自动填充代码注释，提供详细说明如何使用它：

![if](/img/tasks-workflows/if_2.png)

&emsp;&emsp;answer是此高级条件脚本上下文中的预定义变量。这个变量是一个字符串，而不是一个布尔值；它应该设置为字符串yes或no.
脚本运行后，无论答案变量设置为什么，都将确定是否激活了yes或no退出条件：

![if](/img/tasks-workflows/if_3.png)

&emsp;&emsp;例如，您可以使用此脚本字段来查找相关记录或子记录，并根据是否有任何相关记录被取消，例如，将工作流转移到另一条路径，如下所示：

    answer = 'no';
    var gr = new GlideRecord('table_name');
    gr.addQuery('state', '7');
    gr.addQuery('parent', current.getValue('sys_id'));
    gr.setLimit(1);
    gr.query(); ”
    “if (gr.hasNext()) {
        answer = 'yes';
    }

### 提示

&emsp;&emsp;如果前面的代码对您来说还没有多大意义，请不要担心，我们将GlideRecord在本书的后面部分学习有关该类和 Glide API 的所有内容。

### Switch

&emsp;&emsp;If条件活动在事件只有两种退出状态：真和假，或者是和否。如果您希望您的工作流根据特定字段的值遵循单独的路径，例如给定工单的影响，您可能会发现使用Switch更有利或更方便。Switch以字段的潜在值为中心，特别适用于具有固定数量潜在值的下拉字段：

![switch](/img/tasks-workflows/switch.png)

![switch](/img/tasks-workflows/switch_2.png)

&emsp;&emsp;虽然您可以让每个退出条件流转到不同的活动，但有两个或多个Switch退出是完全可以的条件流转为仅一项活动.

### 提示

&emsp;&emsp;当流转（活动之间的线）相交时，有时可能很难看到每条线的结束位置。要查看一行的完整路径，只需单击以选择并突出显示它！

### 等待条件

&emsp;&emsp;等待条件工作流活动允许您指定简单条件（使用条件构建器）或脚本。与普通的 JavaScript 函数（但类似于 ServiceNow 中的许多脚本字段）不同，此脚本的目的不是返回任何内容，而是将预定义的变量（称为answer）设置为true或false。你可以在任何服务器端脚本中做任何你可以做的事情，但是在脚本完成运行后设置的任何变量都将是结果：

![waitCondition](/img/tasks-workflows/waitCondition.png)

&emsp;&emsp;关于等待条件工作流活动要记住的一件事是，它仅在与工作流关联的记录更新时才（重新）评估。任何更新都会触发对该条件的重新评估，但更新另一条记录不会。为了帮助我们理解这一点，让我们想象以下场景：

&emsp;&emsp;想象一下，您有一个与事件工单关联的工作流，并且该工作流运行一个脚本，该脚本在自定义表中生成另一个外部记录。接下来，工作流流转到等待条件活动。在这种情况下，等待条件活动被配置为等待外部记录关闭，这由脚本确定。但是，事件工作流不会知道您在关闭外部记录后已更新它，因此您需要稍微推动事件以使其重新运行评估脚本，方法是更新事件。
解决此问题的一种有效方法是将这两个任务关联在一起，然后使用业务规则更新父记录。例如，在自定义表中生成记录时，您可以使用运行工作流记录的引用任务来填充父[parent] 字段。然后，您可以在该自定义表上使用业务规则，该规则在关闭时运行，并通过添加工作注释来更新父记录。这将有效地推动记录，工作流将重新评估条件。

### 提示

&emsp;&emsp;与同时具有条件构建器字段和条件脚本字段的大多数记录一样，等待条件活动中的这些字段必须都评估为真（如果使用）。










