---
sidebar_position: 2
sidebar_label: '客户端与服务器端API'
---
脚本编写是 JET 的重要组成部分，许多不同类型的记录都支持在一个或多个字段中编写脚本，有些脚本在服务器端执行，有些脚本在客户端执行，脚本是在客户端上还是在服务器端上执行，都决定了它有权访问的 API。

服务器脚本在服务器端上执行时，可以访问一组与客户端脚本不同的编程接口，因为客户端脚本在浏览器中执行。因此，只有包含在网页中并从服务器发送到浏览器的脚本才能从客户端脚本中执行或调用。由于将整个脚本库从服务器发送到客户端以包含在每个页面中是不切实际的，并且会对性能产生负面影响，因此仅包含 API 的修改子集。幸运的是，这个子集包含的内容之一是用于和客户端的服务器端脚本进行交互的 API 类，这个 API 叫做 **GlideAjax** ，稍后将详细介绍此 API。

此外，重要的是要意识到服务器正在运行 Mozilla Rhino；JavaScript 的开源实现，是完全使用 **Java** 编写。Rhino 被嵌入到 JET 服务器中，以便在服务器上提供 JavaScript API 。因此，这允许对某些 Java 特定功能（以及特定于 Java 的问题）的特殊访问权限，而这些功能是客户端脚本所没有的。同样，执行客户端的脚本可以访问自己的特定作用域，由于它们是在用户的浏览器中执行的，因此它们将可以访问 JavaScript ES6 语法（除非用户使用的浏览器版本较低），而 JET 的 Mozilla Rhino 实现只支持服务器端脚本上的 ES5（如果你运行的是Geneva或更早版本也支持ES3）。
虽然对整个 JET API 的完整描述不在本章的讨论范围之内，但客户端和基于服务器的脚本的 API 存在一些重大差异。例如，不能从服务器端脚本中使用 g_form API ，同样也不能从客户端脚本中使用 gs.getValue API。

### 提示
***注：g_list暂未实现***  
正如之前所看到的，有一些对 API（如 GlideForm）的简写引用，g_form 对象是对 GlideForm 的引用，因此可以认为两者是可互通的。同样，g_list 是对 GlideList2 或 GlideListV3 的引用，具体取决于页面中加载的列表版本。gs 是对 GlideSystem 的引用，g_user 是对 GlideUser 的引用。这些 API 使用以 g_xx 开头的接口引用，因为它们没有使用 new 关键字调用的构造函数方法。

虽然我们将在后面的章节中更深入地介绍 glide API，但让我们从学习客户端和服务器上可用的 API 和对象开始，您会注意到，某些对象同时存在于客户端和服务器上，但在一个对象上的效果与另一个对象的效果大有不同。